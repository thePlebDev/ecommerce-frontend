WHAT NEEDS TO BE DONE:

----------------home page------------------------------
1) create the nav bar with navigation to the check out, with react router. (DONE)
2)tests
3)Create the image carousel components
4)tests

----------------individual cards-----------------------
1) create the  idividual  image card carousel
2) add reviews
3) add a buy button
4)tests

----------------checkout-------------------------------
1) create a form that has all the orders
2) add a remove order function
3)tests
4) launch


- so the first thing that is going to be create is the navbar, I will create that with material ui



MATERIAL UI:
- material ui needs to be installed
- so it looks like material ui has already styled components and then to alter them we can pass props, we can find out
what these props are on the docs.
- the Roboto font will not be automaticall loaded by Material-ui. so we have to put a link to the google font in our
index.html
- we add the recommended responsive meta tag to our header.
- there is also an optional css reset. you import CssBaseline  and then put it imbetween a react Fragement but I do not
know what A React Fragement is so, I will have to read up on it.

REACT FRAGMENTS:
- it is common for a React component to return multiple elements. Fragments let us group a list of children without adding
extra nodes to the dom. so then what is the dom and what are nodes
the dom: it connects web pages to scripts or programming languages by representing the structure of a document.The DOM
represents a document with a logical tree, each branch of the tree ends in a node, each node contains objects. DOM methods
allow programmatic access to the tree. with those nodes we can change the document's structure, style and content.
- so the DOM basically represents the page so that we can change the document structure, style and content. the DOM represents the
document as nodes and objects, that way, programming languages can connect to the page. so the dom is basically just
a big object that allows us to interat with the web page. nodes are just elements inside the DOM that we can grab on to and
manipulate.

- so when it says that React Fragments lets us group children without adding extra nodes to the DOM, it is saying that we
are getting structure for free and no space is being added to the DOM

ok so just to be clear what is a component in react: components are what lets us split up the code into more reuseable parts
what are elements in react: they are the smallest building block of React apps, an element describes what you
want to see on the screen. elements are what components are made of. React elements are immutable


THEMING:
- so we can customize material-UI with our own theme, themes let us applu a consistent tone to our app. by default
we get to choose from light and dark themes and initialy the light theme is used for us.
- if we wan to customize a theme we need to provide a ThemeProvider component in order to inject a theme into our
application
- when changing the theme we need to make sure that the themeProvider component is a parent component of the component
that we are trying to change the theme on, this is the only way that it will work.

OVER RIDING COMPONENTS:
there are 5 ways that components can be changed
1) specific variation for a one-time situation
2)synamic variation for a one-time situation
3)specific variation of a component
4)material design variation
5) global theme variation

1)
-so when we want to customize the navbar component we want to over ride somethings, we wont use themeing, that is for
styles, we need to
-so by the sounds of things we want to make a specific cariation for a one-time situation, so making one change to one
component

- the first wat to override the style of a component is to use class names, every component provides a className property
which is always applied to the root element
- one way to override is to use the withStyles() higher-order component to inject custom styles into the DOM, and to pass
the class name to the ClassNames component via its classes ptoperty

-so basically we use a higher order component called withStyles() to inject css styles into the DOM and pass the className
to the component via its props
-so we are injecting styles into the DOM via HOF(withStyles), then we pass the className to the component via props
-so I think I understand, I just need to figure out what styles I want to send them
- our NavBar just uses the AppBar.

- so what I want to do is override the styles so that I can make it so the checkout and home button are in the middle of
the navbar. The outer container that is holding them is in display flex, so I need to read more about that.
-so in our case the reason that it is displayed the way that it is, is because the h6 element is has a width of almost the
entire page, so I need to override this. so It doesnt appear to be the width but lets just start with that and see if
we can override it.
-so we will use the HOF(withStyles) to inject styles of the highest specificity to override the current styles.
- we then pass this new className to our component via the props system
- there is a weird little dependency called clsx, that is used for creating className strings conditionaly

- so the first thing that we do is create the styles, which will be created in an object called styles, that object
will have a property called, root that will calso be an object. The root object will have the styles on it.
- so it looks like the HOF withStyles does a little magic with the styles and the component
- so it injects the styles that we have written to the DOM and then it passes the className to the component via its
classes property
- so the withStyles HOF injects the styles into the DOM, then it passess the wanted class name to the component via the
classes prop

- there is also a children prop and I am not sure what it does.

children: sometimes a component doesnt know their children ahead of time. When that is the case, the special children
prop is used to pass children elements directly into their output. so when you use children in a component it means
that anything that is put between that componnets tags  are going to be rendered inside of it. So anything that is
passed between the opening and closing tag of the component tag is going to added to props as a child prop

- I actually already see that the NavBar is being styled with classes so I might as well just use thos classes

- so when the className property from material ui isnt enouhg we can take advantage of the classes object property
to customize all the css injected by Material-ui for a given component.
-so there seems to be alot of  style HOF and I will have to read more about them, because I have no idea what they are
about.

- so makeStyle is a hook generator that allows the creation of multiple style rules per style sheet. Each style rule has its own class name
- the class names are provided to the component with the classes varible. This is particularly useful when styling
nested elements in a component.
- so I think I got what I wanted and all I had to do was just over ride somethings, three hours of stufy for 5 mins of code

- now I should really read up more on the REACT router

REACT ROUTER:
-so react router helps us create single page applications but what are single page applciations, I should read up on that

- so a SPA ia an application that re-renders its content in response to navigation actions without making a request to the server
to fetch new HTML
- single page apps rely on a router. routers are made up of routes, which describe the location that they should match



HOW BROWSERS HANDLE LOCATIONS:
- each browser tab has a "browser context". the Browsing context maintains a "session history", which is essentially
an array of location entries.
- so basically the sessions storage keeps track of your past history
- when a browser navigates, a request is sent to a server and the browser uses the response to create a DOM
- as you click links and navigate through pages, the browser tab is building up a session history. each navigation
makes a request to a server and creates a new entry, including a new DOM


THE HISTORY API:
-it just provides an object that we can use useful methods and properties that let us nivigate back and forth through
the user's history, and manipulate the contents of the history stack.
- instead of creating a new DOM for every location the Histoy API re-uses the active DOM by updating it to reflect the
new location.


REACT ROUTER:
-when starting a new project, you need to determine which type of router to use. For browser based projects there are
<BrowserROuter> and <HashRouter> components.
- we should use BrowserROuter when our server will handle dynamic requests (know how to respond to any possible URL)
- HashRouter should be used for static websites(where the server can only respond to requests for filed  that is knows about )

- each router creates a history object. which
- the ROuter component only expects to recieve a single child element. so we wrap our App component with the router
tag

- so the route component is the main building block of React Router. Anywhere that we want to only render content based
on the location's pathname. We will use a <Route> element. the Route expects a path property and where that path
specifies the route will render a React component. we can use a <switch> component to groupd the <Routes> but the
switch will iterate over its children elements (the routes) and only render the first one that matches the current pathname

- so we create a <Switch/> element and then inside the elemnet tags we place all of our Route components and have them. render a path
as well as a component prop

-it can be useful to group routes that share a common prefix in the same component

PATH PARAMS:
- when there is a varible in a pathname that we want to capture, we use a path param, a path param being /roster/:number
it will capture whatever is in the number position and it will be stored in the props.match.params of the component

- we use the Link component to act as our anchor tag, when clicked it will update the URL and render the content that
we specified but without reloading the page. we have to provide a 'to' prop to the link with the path name so it knows
where to go when the link is clicked

- ok so now I begin implementing the react router, first I have to download it, then I have to wrap my app component with the Router, but why
- so we will wrap our app component inside of a BrowserROuter, the router can only have one component inside of it
and each router will create a history object. this history object will be used to keep track of the curent location
and re-render the website whenever that changes. Other components provided by react Router rely on having that history
object avilable through react's context, so they must be rendered as descendants of a router componnent. if a React Router
component that does not have a router as one of its ancestors will fail to work.
-we are using BrowserRouter because we are using a server that handles dynamic requests.

-so an application server will have a web framework running on top of it. For example, a Node application server
might be running Express. so basically a application server will have a framework running on the backend. That framework
is able to match requests and dynamically generate responses

- so the reason that we have to wrap our component with the router is becasue of the history object that the rest of the COMPONENTS
rely on.
- so now we have to create our routes . so routes can be created anywhere but often it makes sense to render them in the same place
- we can use the <Switch> component to gorup <Route>s. The <Switch/> will iterate overs its children elements(the routes) and
only render the first one that matches the current pathname.
- ok so basically we just use switch to group our routes and then the switch component will iterate over all the children
and only render the first one the matches the current path.

- ok so now we need to go into the app component and wrap everything we want to render in the switch component

-so now that we have our switch component we need to add the individual Routes. The Route will render our component, and we
can even pass it a function if we need it to give a component more props
- since we dont have any extra props to pass to our components we will just use the component prop and not the render one

- we have to put the exact prop on the route that has the path to the home page so that it only matches that path
when it is exactly / and not /home

- so now I need links. I just provide the 'to' prop and state the url that it is going to and
- so now I will push to git hub
- then I will put into play the basic tests and then I will make simple tests and then push again
